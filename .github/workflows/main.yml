name: LLM Moderation Analysis Run

on:
  workflow_dispatch:
  schedule:
    - cron: '0 0 * * 1' # Every Monday at midnight UTC

# Prevents multiple runs from conflicting if a new one starts before the 2-hour job finishes
concurrency:
  group: ${{ github.workflow }}-${{ github.ref }}
  cancel-in-progress: true

jobs:
  run-analysis:
    runs-on: ubuntu-latest
    timeout-minutes: 240 # Safety net for the 2+ hour runtime
    permissions:
      contents: write 

    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          # Fetches all history so rebase has the context it needs
          fetch-depth: 0 

      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: '3.10'
          cache: 'pip'

      - name: Set up Node.js
        uses: actions/setup-node@v3
        with:
          node-version: 20

      - name: Install dependencies
        run: |
          python -m pip install --upgrade pip
          pip install -r requirements.txt

      - name: Run Unit Tests
        env:
          OPENROUTER_API_KEY: "mock_key_for_ci" # Tests won't hit real API due to mocks
        run: |
          # The -m flag ensures we're using the installed module context
          # We ignore depreciation warnings that might clutter logs
          python -m pytest -W ignore::DeprecationWarning

      - name: Run Model Collection (Efficiency Suite with dynamic resolution)
        env:
          OPENROUTER_API_KEY: ${{ secrets.OPENROUTER_API_KEY }}
          PYTHONPATH: .
        run: python src/audit_runner.py --preset all --resolve-latest

      # Logic for analysis is now embedded or we just commit the raw audit log for the dashboard
      # - name: Run Automated Analysis
      #   run: python src/analyze_results.py

      - name: Commit and Push Results
        run: |
          git config --local user.email "github-actions[bot]@users.noreply.github.com"
          git config --local user.name "github-actions[bot]"
          
          # Strategy: Stash local changes, pull latest remote, then re-apply changes.
          # This minimizes conflicts when the remote has moved ahead during the job run.
          
          echo "Stashing local changes..."
          git stash push -m "New analysis data" --include-untracked
          
          echo "Pulling latest changes from remote..."
          git pull --rebase origin main
          
          echo "Restoring local changes..."
          # If stash pop fails due to conflicts, we continue to allow debugging, 
          # but usually for CSV appends it should work or leave markers.
          git stash pop || echo "Warning: Stash pop reported conflicts. Check output."
          
          # Stage all changes (including resolved or marker-filled files)
          git add .
          
          # Only commit if there are changes to avoid erroring out
          if ! git diff --cached --quiet; then
            git commit -m "Auto-update: LLM responses for $(date +%Y-%m-%d)"
            git push origin main
          else
            echo "No changes to commit"
          fi

      - name: Deploy to Vercel
        env:
          VERCEL_TOKEN: ${{ secrets.VERCEL_TOKEN }}
          VERCEL_ORG_ID: ${{ secrets.VERCEL_ORG_ID }}
          VERCEL_PROJECT_ID: ${{ secrets.VERCEL_PROJECT_ID }}
        run: |
          # Copy fresh data to where Next.js expects it
          mkdir -p web/public/data
          # Copy to public for legacy CSV access
          cp audit_log.csv web/public/
          # Copy DB to root of web app for Server-Side access (better-sqlite3)
          cp audit.db web/audit.db
          
          cp data/trends.csv web/public/
          if [ -f "data/latest_report.md" ]; then
            cp data/latest_report.md web/public/
          fi
          
          # DEBUG: Verify file existence
          echo "=== DEBUG: Listing web/public directory ==="
          ls -R web/public
          
          # Deploy
          npx vercel deploy web --prod --token=$VERCEL_TOKEN --yes --debug
